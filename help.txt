Helper File
- credits : youtube.com/jdh

Starting command:

cc src/wolf.c -o main \
  -I/opt/homebrew/include/SDL2 \
  -L/opt/homebrew/lib \
  -lSDL2

Colors:

0xFFFF0000	    Full red
0xFF00FF00	    Full green
0xFF0000FF	    Full blue
0xFFFFFFFF	    Full white
0xFF000000	    Full black
0xFFFFFF00	    Red + Green
0xFF00FFFF	    Green + Blue
0xFFFF00FF	    Red + Blue
0xFF808080	    Equal RGB values
0xFFD3D3D3	    Softer gray
0xFF404040	    Dark tone
0xFFFFA500	    Red + some green
0xFFFFC0CB	    Light red-ish
0xFFA52A2A	    Red-dominant brown
0xFF800080	    Red + Blue, low values
0x00000000	    Fully transparent black

Map:

[WALLS]
[WALL1]
42 43 43 603
[WALL2]
43 603 602 604
[WALL3]
602 604 42 282
[WALL4]
42 282 601 282
[WALL5]
601 282 42 43

Render Game 2:

void render_game() {
    for (i32 x = 0; x < SCREEN_WIDTH; x++) {
        f32 xcam =
            xcam(x);
        v2 ray =
            ray(state.dir, state.plane, xcam),
            pos = state.pos;
        v2i map =
            mapcell(pos),
            step = step(ray);
        v2 delta =
            delta(ray),
            side = sd(pos, map, delta, ray);

        i32 side_hit = 0, val = 0;
        while (!val) {
            if (side.x < side.y) {
                side.x += delta.x;
                map.x += step.x;
                side_hit = 0;
            }
            else {
                side.y += delta.y;
                map.y += step.y;
                side_hit = 1;
            }
            val = MAPDATA[map.y * 8 + map.x];
        }

        u32 color = 0;
        switch (val) {
            case 1: color = 0xFF0000FF; break;
            case 2: color = 0xFF00FF00; break;
            case 3: color = 0xFFFF0000; break;
            case 4: color = 0xFFFF00FF; break;
        }

        if (side_hit) {
            u32 r = ((color >> 16) & 0xFF) * 0.6;
            u32 g = ((color >> 8) & 0xFF) * 0.6;
            u32 b = (color & 0xFF) * 0.6;
            color = (0xFF << 24) | (r << 16) | (g << 8) | b;
        }

        f32 dist = wd(side, delta, side_hit);
        i32 h = wh(dist);
        i32 *yr = wr(h);

        verline(x, 0, yr[0], 0xFF202020);
        verline(x, yr[0], yr[1], color);
        verline(x, yr[1], SCREEN_HEIGHT, 0xFF505050);
    }
}

Render Game 1:

void render_game() {
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        f32 xcam = 2 * (x / (f32)SCREEN_WIDTH) - 1;
        v2 ray = { state.dir.x + state.plane.x * xcam,
                   state.dir.y + state.plane.y * xcam };

        v2 pos = state.pos;

        v2i map = { (int)pos.x,
                    (int)pos.y };

        v2 delta = { fabsf(1.0f / ray.x),
                     fabsf(1.0f / ray.y) };

        v2 side = {
            ray.x < 0 ? (pos.x - map.x) * delta.x : (map.x + 1.0 - pos.x) * delta.x,
            ray.y < 0 ? (pos.y - map.y) * delta.y : (map.y + 1.0 - pos.y) * delta.y, };

        v2i step = { sign(ray.x),
                     sign(ray.y) };

        int side_hit = 0, val = 0;
        while (!val) {
            if (side.x < side.y) { side.x += delta.x; map.x += step.x; side_hit = 0; }
            else { side.y += delta.y; map.y += step.y; side_hit = 1; }
            val = MAPDATA[map.y * 8 + map.x];
        }

        u32 color = 0;
        switch (val) {
            case 1: color = 0xFF0000FF; break;
            case 2: color = 0xFF00FF00; break;
            case 3: color = 0xFFFF0000; break;
            case 4: color = 0xFFFF00FF; break;
        }

        if (side_hit) {
            u32 r = ((color >> 16) & 0xFF) * 0.6;
            u32 g = ((color >> 8) & 0xFF) * 0.6;
            u32 b = (color & 0xFF) * 0.6;
            color = (0xFF << 24) | (r << 16) | (g << 8) | b;
        }

        f32 dist = side_hit ? (side.y - delta.y) : (side.x - delta.x);
        int h = (int)(SCREEN_HEIGHT / dist);
        int y0 = max(0, SCREEN_HEIGHT / 2 - h / 2);
        int y1 = min(SCREEN_HEIGHT, SCREEN_HEIGHT / 2 + h / 2);

        verline(x, 0, y0, 0xFF202020);
        verline(x, y0, y1, color);
        verline(x, y1, SCREEN_HEIGHT, 0xFF505050);
    }
}